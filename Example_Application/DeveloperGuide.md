# Example rApp Technical Specification

## Overview

The Example rApp in Python serves as a reference point for how an rApp can be developed to work with the platform capabilities. Based on a set of discovered cells, the Example rApp reads the operational state and validates that PM counters are being collected.

-----

## Capabilities

The Example rApp uses the following capabilities to implement its use case:

  * **Topology & Inventory**
      * Discover a set of 10 `NRCellDU`s from the network.
  * **Network Configuration**
      * Read the `operationalState` attribute for each `NRCellDU`.
  * **Data Management**
      * Request PM counters for all `NRCellDU`s in the network.
  * **Message Bus**
      * Consume PM counters.

-----

## Third-party packages

The Example rApp uses the following third-party packages:

  * **FastAPI**
      * The main web framework used by the Example rApp.
  * **Uvicorn**
      * The ASGI server which hosts the Example rApp.
  * **Confluent Kafka**
      * The Kafka client used to retrieve PM Counter data from Message Bus. It is implemented in `message_bus_consumer.py`.
  * **Apache Avro**
      * Deserializes messages from the Message Bus. Used in `message_bus_consumer.py`.
  * **APScheduler**
      * Schedules the report generated by the rApp. It is implemented in `report_generator.py`.

To see all the third-party packages used in the Example rApp, see:

  * `requirements.txt` for packages used in the Example rApp Docker™ image.
  * `test_requirements.txt` for packages which enable unit testing.

-----

## Modifying the Example rApp Code

The Example rApp is designed for extensibility. Modules and functions in the source code are annotated with docstrings that help an rApp developer to understand the functionality of the rApp and how they might modify it for their own use case.

### Potential adaptations

Some examples of alternative use case adaptations are explained at a high level. These adaptations require extensive modifications to the code:

  * **Request 4G cells instead of 5G cells**

      * Change the topology query in `topology_and_inventory.py` from `NRCellDU` to `EUtranCellTDD` or `EUTranCellFDD`. **Explore Topology RAN Data Models →**
      * Change the `dmetypeID` and `dataDeliverySchemaId` in `csar/OtherDefinitions/DataManagement/data-access-configuration.json` to request 4G PM counters. **Find out more about requesting PM counter data →**
      * Change the filtering criteria in `message_bus_consumer.py` from `NRCellDU_GNBDU` to `EUTranCellTDD` or `EUTranCellFDD`. **Read more about schema mappings →**

  * **Find and choose an alternative attribute of `NRCellDU`**

      * **Find attributes of NRCellDU →**
      * Edit the instance of the `ReportGenerator` in `server.py` with the new attribute.

  * **Extract specific counter values from incoming messages**

      * Instead of setting a flag for successful counter collection, edit `_set_counter_status()` in `message_bus_consumer.py` to read a specific counter value. **Use the Data Discovery APIs to find available counters →**
      * Additional edits are needed for the `ReportGenerator` in `report_generator.py` as well as the module-level variable `fdn_to_pm_counter_status` from `message_bus_consumer.py` to display your chosen counter.

-----

## Renaming the Example rApp

The Example rApp must be assigned a unique name. **rApps with duplicate names cannot exist on the platform.**

To make the Example rApp unique, replace the placeholder `RAPP_NAME` with a unique name throughout the project files.

> **Note:** Run the following commands in the rApp root directory.

### Step 1: Make the script executable

Before running the script, give it execute permissions:

```sh
chmod +x set_rapp_name.sh
```

### Step 2: Set your unique rApp name

Choose a unique name for the Example rApp and set it as an environment variable:

```sh
export RAPP_NAME="<RAPP_NAME>"
```

**Example command:**

```sh
export RAPP_NAME="my-new-rapp"
```

### Step 3: Run the script to apply the name

Execute the script to automatically replace all instances of `RAPP_NAME` with a new name:

```sh
./set_rapp_name.sh
```

-----

## Testing the Example rApp

Before running unit tests, download third-party dependencies.

> **Note:** Run the following command in the rApp root directory:

```sh
pip install -r requirements.txt -r test_requirements.txt
```

Once testing dependencies are installed, run unit tests. The example output will look like this:

```
tests/test_data_management.py ...                                 [  8%]
tests/test_message_bus_consumer.py ......                         [ 25%]
tests/test_mtls_logging.py ..........                             [ 52%]
tests/test_network_configuration.py ..                            [ 58%]
tests/test_report_generator.py ...                                [ 66%]
tests/test_server.py ..........                                   [ 94%]
tests/test_topology_and_inventory.py ..                           [100%]
```

When using the Example rApp as the base of a new rApp, ensure that automated testing is set up on top of the provided unit tests.

**Read more about testing in the Developer Pathway →**

### Changing resource allocation

It is the responsibility of the developer to test and profile the Example rApp before using it if:

  * Changes are made to the use case.
  * The Example rApp is deployed, without any changes, on a network larger than defined in the Cloud Resources.

**See the Example rApp base Cloud Resources requirements →**

The Example rApp resource limits and requests are configurable in `Values.yaml`.

-----

## Configuring the Message Bus consumer

The Confluent Kafka client used as a Message Bus consumer can be configured in `Values.yaml`. The following values can be modified:

  * `consumerMessageBatchSize: "100"` - The amount of messages to consume at once. A larger batch size eliminates some network delay from repeated polling. The batch size should only be increased if the Example App is provided with more CPU.
  * `consumerTimeout: "30.0"` - Seconds that the application waits to fill a batch. If a batch is filled before this timeout is reached, deserialization begins early.

